<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[js设计模式]]></title>
    <url>%2F2018%2F07%2F25%2Fjs%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[爱心飘 取消 单例模式:&emsp;&emsp;保证一个类仅有一个实例，并提供一个访问它的全局访问点。实现的方法为先判断实例存在与否，如果存在则直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。&emsp;&emsp;适用场景：一个单一对象。比如：新建单例如弹窗提示，无论点击多少次，单例只被被创建一次。 新建单例 class danli180725 { constructor(name, hobby) { this.name = name; this.hobby = hobby; } describe() { document.getElementById('test180725').innerHTML=this.name + ' 被创建啦,他/她的爱好是 ' + this.hobby; } }; var proxyMode180725 = (function(){ var instance = null; return function(name,hobby){ if(!instance){ instance = new danli180725(name, hobby); } return instance; } })(); function set180725(){ var name = document.getElementById('name180725').value; var hobby = document.getElementById('hobby180725').value; if(!name){ name = '默认宝'; } if(!hobby){ hobby = '默认吃'; } var danli = proxyMode180725(name,hobby); danli.describe(); }]]></content>
  </entry>
  <entry>
    <title><![CDATA[雪花测试]]></title>
    <url>%2F2018%2F07%2F24%2F%E9%9B%AA%E8%8A%B1%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[下雪 取消 // 存储所有的雪花 const snows = []; // 下落的加速度 const G = 0.01; const fps = 60; // 速度上限，避免速度过快 const SPEED_LIMIT_X = 1; const SPEED_LIMIT_Y = 1; const W = window.innerWidth; const H = window.innerHeight; let theAnimation let snowing = false let tickCount = 150; let ticker = 0; let lastTime = Date.now(); let deltaTime = 0; let canvas = null; let ctx = null; let snowImage = null; window.requestAnimationFrame = (function() { return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) { setTimeout(callback, 1000 / fps); } })(); function cancel() { snowing = false cancelAnimationFrame(theAnimation) $('.snows').css('display','none') } function init(type) { if(snowing){ return } snowing = true; createCanvas(); canvas.width = W; canvas.height = H; canvas.style.cssText = 'position: fixed; top: 0; left: 0; pointer-events: none;'; document.body.appendChild(canvas); // 小屏幕时延长添加雪花时间，避免屏幕上出现太多的雪花 if(W < 768) { tickCount = 350; } snowImage = new Image(); switch(type){ case 'snow': snowImage.src = 'http://218.75.110.40:9104/hVisual/resource/hVisual/swt/snow.png'; break; case 'heart': snowImage.src = 'http://218.75.110.40:9104/hVisual/resource/hVisual/swt/heartred.png'; break; default: snowImage.src = 'http://218.75.110.40:9104/hVisual/resource/hVisual/swt/snow.png'; } loop(); } function loop() { theAnimation = requestAnimationFrame(loop); ctx.clearRect(0, 0, W, H); const now = Date.now(); deltaTime = now - lastTime; lastTime = now; ticker += deltaTime; if(ticker > tickCount) { snows.push( new Snow(Math.random() * W, 0, Math.random() * 5 + 5) ); ticker %= tickCount; } const length = snows.length; snows.map(function(s, i) { s.update(); s.draw(); if(s.y >= H) { snows.splice(i, 1); } }); } function Snow(x, y, radius) { this.x = x; this.y = y; this.sx = 0; this.sy = 0; this.deg = 0; this.radius = radius; this.ax = Math.random() < 0.5 ? 0.005 : -0.005; } Snow.prototype.update = function() { const deltaDeg = Math.random() * 0.6 + 0.2; this.sx += this.ax; if(this.sx >= SPEED_LIMIT_X || this.sx]]></content>
  </entry>
  <entry>
    <title><![CDATA[图片测试]]></title>
    <url>%2F2018%2F07%2F23%2F%E5%9B%BE%E7%89%87%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
</search>
